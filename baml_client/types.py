# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict, Field


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (3)
# #########################################################################

class AggregationType(str, Enum):
    Total = "Total"
    Sum = "Sum"
    Min = "Min"
    Max = "Max"
    Average = "Average"
    Count = "Count"
    NoAggregation = "NoAggregation"

class Confidence(str, Enum):
    High = "High"
    Medium = "Medium"
    Low = "Low"

class TableType(str, Enum):
    FlatHeader = "FlatHeader"
    HierarchicalHeader = "HierarchicalHeader"
    PivotedTable = "PivotedTable"
    TransposedTable = "TransposedTable"
    Unknown = "Unknown"

# #########################################################################
# Generated classes (12)
# #########################################################################

class AggregationInfo(BaseModel):
    type: AggregationType
    axis: str = Field(description='\'row\' or \'column\' â€” the axis along which aggregation runs')
    labels: typing.List[str] = Field(description='Labels identifying aggregation rows/columns, e.g. [\'Total\', \'Grand Total\']')

class CanonicalSchema(BaseModel):
    columns: typing.List["ColumnDef"]
    description: typing.Optional[str] = Field(default=None, description='Optional description of what this schema represents')

class ColumnDef(BaseModel):
    name: str = Field(description='Canonical column name')
    type: str = Field(description='Expected type: string, int, float, bool, date')
    description: str = Field(description='What this column represents')
    aliases: typing.List[str] = Field(description='Alternative names this column may appear as in source tables')

class FieldMapping(BaseModel):
    column_name: str = Field(description='Canonical column name from the schema')
    source: str = Field(description='Where the value came from, e.g. \'column: Vessel Name\', \'section header\', \'document title\', \'inferred from context\'')
    rationale: str = Field(description='Brief explanation of why this mapping was chosen')
    confidence: Confidence

class HeaderInfo(BaseModel):
    levels: int = Field(description='Number of header rows. For FlatHeader with stacked/multiline labels, this counts the text rows but names[][] should contain the combined column names. For HierarchicalHeader, this counts the hierarchy depth.')
    names: typing.List[typing.List[str]] = Field(description='Header names per level, outer = level, inner = columns. For FlatHeader (even with multiline labels), use a single level with combined names. For HierarchicalHeader, each level represents a tier in the tree.')

class InferredTableSchema(BaseModel):
    column_names: typing.List[str] = Field(description='Column headers as they visually appear in the table, left to right. For stacked/multiline headers, combine the vertically stacked labels into a single name per column (e.g. \'Unique Slot Reference Number\'). For hierarchical headers with spanning parents, use compound paths (e.g. \'Q1 2025 / Revenue\').')
    column_count: int = Field(description='Total number of data columns')
    header_levels: int = Field(description='Number of header rows (1 for single-row, >1 for stacked/multiline or hierarchical)')
    has_spanning_headers: bool = Field(description='True if parent cells span multiple child columns (hierarchical). False if headers are just stacked text with no spanning (multiline flat).')
    notes: typing.Optional[str] = Field(default=None, description='Observations about the header structure: merged cells, stacked labels, spanning parent cells, visual groupings, etc.')

class InterpretationMetadata(BaseModel):
    model: str = Field(description='Model that produced this result, e.g. \'openai/gpt-4o\'')
    table_type_inference: "TableTypeInference" = Field(description='The table type from Step 1 and which mapping strategy was applied')
    field_mappings: typing.List["FieldMapping"] = Field(description='One entry per canonical column, explaining how it was resolved')
    sections_detected: typing.Optional[typing.List[str]] = Field(default=None, description='Section/group labels found in the text, if any (e.g. [\'GERALDTON\', \'KWINANA\'])')
    section_role: typing.Optional[str] = Field(default=None, description='\'context\' if a single section label applies to all rows, \'grouping\' if multiple labels partition rows into groups')

class MappedRecord(BaseModel):
    model_config = ConfigDict(extra='allow')

class MappedTable(BaseModel):
    records: typing.List["MappedRecord"] = Field(description='Mapped data records conforming to the canonical schema')
    unmapped_columns: typing.List[str] = Field(description='Source columns that could not be mapped to any canonical column')
    mapping_notes: typing.Optional[str] = Field(default=None, description='Notes about the mapping process, e.g. ambiguous matches or type coercion issues')
    metadata: "InterpretationMetadata" = Field(description='Metadata about the interpretation: model used, per-field mapping rationale, detected sections')

class ParsedTable(BaseModel):
    table_type: TableType
    headers: "HeaderInfo"
    aggregations: typing.Optional["AggregationInfo"] = Field(default=None, description='Present only if the table contains aggregation rows/columns')
    data_rows: typing.List[typing.List[str]] = Field(description='All data rows (excluding headers and aggregation rows). Each inner array is one row of cell values as strings.')
    notes: typing.Optional[str] = Field(default=None, description='Any caveats or observations about the table structure')

class Resume(BaseModel):
    name: str
    email: str
    experience: typing.List[str]
    skills: typing.List[str]

class TableTypeInference(BaseModel):
    table_type: TableType = Field(description='Table type from Step 1 (do not re-classify)')
    mapping_strategy_used: str = Field(description='Which mapping strategy was applied: \'1:1 row mapping\', \'unpivot\', \'transpose\'')

# #########################################################################
# Generated type aliases (0)
# #########################################################################
