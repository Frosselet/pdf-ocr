# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from enum import Enum


from pydantic import BaseModel, ConfigDict, Field


import baml_py

CheckT = typing_extensions.TypeVar('CheckT')
CheckName = typing_extensions.TypeVar('CheckName', bound=str)

class Check(BaseModel):
    name: str
    expression: str
    status: str
class Checked(BaseModel, typing.Generic[CheckT, CheckName]):
    value: CheckT
    checks: typing.Dict[CheckName, Check]

def get_checks(checks: typing.Dict[CheckName, Check]) -> typing.List[Check]:
    return list(checks.values())

def all_succeeded(checks: typing.Dict[CheckName, Check]) -> bool:
    return all(check.status == "succeeded" for check in get_checks(checks))
# #########################################################################
# Generated enums (8)
# #########################################################################

class AggregationType(str, Enum):
    Total = "Total"
    Sum = "Sum"
    Min = "Min"
    Max = "Max"
    Average = "Average"
    Count = "Count"
    NoAggregation = "NoAggregation"

class Confidence(str, Enum):
    High = "High"
    Medium = "Medium"
    Low = "Low"

class HeaderOrientation(str, Enum):
    Top = "Top"
    Left = "Left"

class HeaderStructure(str, Enum):
    SingleRow = "SingleRow"
    Stacked = "Stacked"
    Hierarchical = "Hierarchical"

class MultiRowPattern(str, Enum):
    SingleRow = "SingleRow"
    RepeatingGroup = "RepeatingGroup"

class PageSectionType(str, Enum):
    TableHeader = "TableHeader"
    DataGrid = "DataGrid"
    SectionHeading = "SectionHeading"
    Metadata = "Metadata"
    Prose = "Prose"
    AggregationRow = "AggregationRow"
    Footnote = "Footnote"

class TableLayout(str, Enum):
    Standard = "Standard"
    Transposed = "Transposed"
    CrossTab = "CrossTab"

class TableType(str, Enum):
    FlatHeader = "FlatHeader"
    HierarchicalHeader = "HierarchicalHeader"
    PivotedTable = "PivotedTable"
    TransposedTable = "TransposedTable"
    Unknown = "Unknown"

# #########################################################################
# Generated classes (16)
# #########################################################################

class AggregationInfo(BaseModel):
    type: AggregationType
    axis: str = Field(description='\'row\' or \'column\' â€” the axis along which aggregation runs')
    labels: typing.List[str] = Field(description='Labels identifying aggregation rows/columns, e.g. [\'Total\', \'Grand Total\']')

class CanonicalSchema(BaseModel):
    columns: typing.List["ColumnDef"]
    description: typing.Optional[str] = Field(default=None, description='Optional description of what this schema represents')

class ColumnDef(BaseModel):
    name: str = Field(description='Canonical column name')
    type: str = Field(description='Expected type: string, int, float, bool, date')
    description: str = Field(description='What this column represents')
    aliases: typing.List[str] = Field(description='Alternative names this column may appear as in source tables')
    format: typing.Optional[str] = Field(default=None, description='Output format specification. For dates: YYYY-MM-DD, YYYY-MM, HH:mm:ss, etc. For numbers: #,###.## (thousands + decimals), +# (explicit sign), #% (percentage). For strings: uppercase, lowercase, titlecase, camelCase, PascalCase, snake_case, kebab-case, trim.')

class DetectedTable(BaseModel):
    layout: TableLayout = Field(description='Geometric arrangement of records and fields in the table.')
    header_structure: HeaderStructure = Field(description='Vertical organization of the column labels.')
    column_names: typing.List[str] = Field(description='Column headers, one per data column.')
    data_rows: typing.List[typing.List[str]] = Field(description='Data rows. Each inner array has one cell value per column.')
    notes: typing.Optional[str] = Field(default=None, description='Observations: sections found, aggregation rows excluded, etc.')

class FieldMapping(BaseModel):
    column_name: str = Field(description='Canonical column name from the schema')
    source: str = Field(description='Where the value came from, e.g. \'column: Field A\', \'section header\', \'document title\', \'inferred from context\'')
    rationale: str = Field(description='Brief explanation of why this mapping was chosen')
    confidence: Confidence

class HeaderInfo(BaseModel):
    levels: int = Field(description='Number of header rows.')
    names: typing.List[typing.List[str]] = Field(description='Header names per level, outer = level, inner = columns.')

class InferredTableSchema(BaseModel):
    column_names: typing.List[str] = Field(description='Column headers as they visually appear in the table, left to right. One entry per data column.')
    column_count: int = Field(description='Total number of data columns')
    header_levels: int = Field(description='Number of header rows (1 for single-row, >1 for stacked/multiline or hierarchical)')
    has_spanning_headers: bool = Field(description='True if parent cells span multiple child columns (hierarchical). False otherwise.')
    notes: typing.Optional[str] = Field(default=None, description='Observations about the header structure: merged cells, stacked labels, spanning parent cells, visual groupings, etc.')

class InterpretationMetadata(BaseModel):
    model: str = Field(description='Model that produced this result, e.g. \'openai/gpt-4o\'')
    table_type_inference: "TableTypeInference" = Field(description='The table type from Step 1 and which mapping strategy was applied')
    field_mappings: typing.List["FieldMapping"] = Field(description='One entry per canonical column, explaining how it was resolved')
    sections_detected: typing.Optional[typing.List[str]] = Field(default=None, description='Section/group labels found in the text, if any (e.g. [\'GROUP A\', \'GROUP B\'])')
    section_role: typing.Optional[str] = Field(default=None, description='Role of section labels: \'context\' or \'grouping\'')

class MappedRecord(BaseModel):
    model_config = ConfigDict(extra='allow')

class MappedTable(BaseModel):
    records: typing.List["MappedRecord"] = Field(description='Mapped data records conforming to the canonical schema')
    unmapped_columns: typing.List[str] = Field(description='Source columns that could not be mapped to any canonical column')
    mapping_notes: typing.Optional[str] = Field(default=None, description='Notes about the mapping process, e.g. ambiguous matches or type coercion issues')
    metadata: "InterpretationMetadata" = Field(description='Metadata about the interpretation: model used, per-field mapping rationale, detected sections')

class PageSection(BaseModel):
    type: PageSectionType = Field(description='What kind of content this section contains.')
    label: typing.Optional[str] = Field(default=None, description='Text label for this section (e.g. heading text, group name). Null for unlabeled sections.')
    row_range: typing.Optional[str] = Field(default=None, description='Row range in the spatial grid, e.g. \'0-3\' or \'4-35\'.')

class ParsedTable(BaseModel):
    table_type: TableType
    headers: "HeaderInfo"
    aggregations: typing.Optional["AggregationInfo"] = Field(default=None, description='Present only if the table contains aggregation rows/columns')
    data_rows: typing.List[typing.List[str]] = Field(description='All data rows. Each inner array is one row of cell values as strings.')
    notes: typing.Optional[str] = Field(default=None, description='Any caveats or observations about the table structure')

class RefinedHeaders(BaseModel):
    header_structure: HeaderStructure = Field(description='Vertical organization of the column labels.')
    header_row_count: int = Field(description='Number of rows occupied by column labels.')
    column_names: typing.List[str] = Field(description='Clean column names, one per data column.')
    notes: typing.Optional[str] = Field(default=None, description='Observations: merged cells, spanning parents, missing headers, etc.')

class Resume(BaseModel):
    name: str = Field(description='Full name of the person')
    email: str = Field(description='Email address')
    experience: typing.List[str] = Field(description='List of work experience entries (e.g. role and company)')
    skills: typing.List[str] = Field(description='List of technical or professional skills')

class TableStructure(BaseModel):
    layout: TableLayout = Field(description='Geometric arrangement of records and fields.')
    header_structure: HeaderStructure = Field(description='How column labels are organized vertically.')
    header_orientation: HeaderOrientation = Field(description='Whether labels are above (Top) or left of (Left) data.')
    header_row_count: int = Field(description='Number of rows occupied by headers. Data begins after this count.')
    multi_row_pattern: MultiRowPattern = Field(description='Whether records span multiple rows.')
    multi_row_period: typing.Optional[int] = Field(default=None, description='Rows per record when multi_row_pattern is RepeatingGroup. Null otherwise.')
    data_column_count: int = Field(description='Number of data columns in the table body.')
    column_names: typing.List[str] = Field(description='Resolved column names, one per data column. For Stacked headers, these are the vertically concatenated names. For Hierarchical, these are compound \'Parent / Child\' paths.')
    notes: typing.Optional[str] = Field(default=None, description='Observations about structure: ambiguities, confidence, unusual patterns.')

class TableTypeInference(BaseModel):
    table_type: TableType = Field(description='Table type from Step 1 (do not re-classify)')
    mapping_strategy_used: str = Field(description='Which mapping strategy was applied: \'1:1 row mapping\', \'unpivot\', \'transpose\'')

# #########################################################################
# Generated type aliases (0)
# #########################################################################
