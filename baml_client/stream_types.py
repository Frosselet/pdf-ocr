# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

import typing
import typing_extensions
from pydantic import BaseModel, ConfigDict, Field

import baml_py

from . import types

StreamStateValueT = typing.TypeVar('StreamStateValueT')
class StreamState(BaseModel, typing.Generic[StreamStateValueT]):
    value: StreamStateValueT
    state: typing_extensions.Literal["Pending", "Incomplete", "Complete"]
# #########################################################################
# Generated classes (12)
# #########################################################################

class AggregationInfo(BaseModel):
    type: typing.Optional[types.AggregationType] = None
    axis: typing.Optional[str] = Field(default=None, description='\'row\' or \'column\' â€” the axis along which aggregation runs')
    labels: typing.List[str] = Field(description='Labels identifying aggregation rows/columns, e.g. [\'Total\', \'Grand Total\']')

class CanonicalSchema(BaseModel):
    columns: typing.List["ColumnDef"]
    description: typing.Optional[str] = Field(default=None, description='Optional description of what this schema represents')

class ColumnDef(BaseModel):
    name: typing.Optional[str] = Field(default=None, description='Canonical column name')
    type: typing.Optional[str] = Field(default=None, description='Expected type: string, int, float, bool, date')
    description: typing.Optional[str] = Field(default=None, description='What this column represents')
    aliases: typing.List[str] = Field(description='Alternative names this column may appear as in source tables')
    format: typing.Optional[str] = Field(default=None, description='Output format specification. For dates: YYYY-MM-DD, YYYY-MM, HH:mm:ss, etc. For numbers: #,###.## (thousands + decimals), +# (explicit sign), #% (percentage). For strings: uppercase, lowercase, titlecase, camelCase, PascalCase, snake_case, kebab-case, trim.')

class FieldMapping(BaseModel):
    column_name: typing.Optional[str] = Field(default=None, description='Canonical column name from the schema')
    source: typing.Optional[str] = Field(default=None, description='Where the value came from, e.g. \'column: Vessel Name\', \'section header\', \'document title\', \'inferred from context\'')
    rationale: typing.Optional[str] = Field(default=None, description='Brief explanation of why this mapping was chosen')
    confidence: typing.Optional[types.Confidence] = None

class HeaderInfo(BaseModel):
    levels: typing.Optional[int] = Field(default=None, description='Number of header rows. For FlatHeader with stacked/multiline labels, this counts the text rows but names[][] should contain the combined column names. For HierarchicalHeader, this counts the hierarchy depth.')
    names: typing.List[typing.List[str]] = Field(description='Header names per level, outer = level, inner = columns. For FlatHeader (even with multiline labels), use a single level with combined names. For HierarchicalHeader, each level represents a tier in the tree.')

class InferredTableSchema(BaseModel):
    column_names: typing.List[str] = Field(description='Column headers as they visually appear in the table, left to right. For stacked/multiline headers, combine the vertically stacked labels into a single name per column (e.g. \'Unique Slot Reference Number\'). For hierarchical headers with spanning parents, use compound paths (e.g. \'Group A / Metric 1\').')
    column_count: typing.Optional[int] = Field(default=None, description='Total number of data columns')
    header_levels: typing.Optional[int] = Field(default=None, description='Number of header rows (1 for single-row, >1 for stacked/multiline or hierarchical)')
    has_spanning_headers: typing.Optional[bool] = Field(default=None, description='True if parent cells span multiple child columns (hierarchical). False if headers are just stacked text with no spanning (multiline flat).')
    notes: typing.Optional[str] = Field(default=None, description='Observations about the header structure: merged cells, stacked labels, spanning parent cells, visual groupings, etc.')

class InterpretationMetadata(BaseModel):
    model: typing.Optional[str] = Field(default=None, description='Model that produced this result, e.g. \'openai/gpt-4o\'')
    table_type_inference: typing.Optional["TableTypeInference"] = Field(default=None, description='The table type from Step 1 and which mapping strategy was applied')
    field_mappings: typing.List["FieldMapping"] = Field(description='One entry per canonical column, explaining how it was resolved')
    sections_detected: typing.Optional[typing.List[str]] = Field(default=None, description='Section/group labels found in the text, if any (e.g. [\'GERALDTON\', \'KWINANA\'])')
    section_role: typing.Optional[str] = Field(default=None, description='\'context\' if a single section label applies to all rows, \'grouping\' if multiple labels partition rows into groups')

class MappedRecord(BaseModel):
    model_config = ConfigDict(extra='allow')

class MappedTable(BaseModel):
    records: typing.List["MappedRecord"] = Field(description='Mapped data records conforming to the canonical schema')
    unmapped_columns: typing.List[str] = Field(description='Source columns that could not be mapped to any canonical column')
    mapping_notes: typing.Optional[str] = Field(default=None, description='Notes about the mapping process, e.g. ambiguous matches or type coercion issues')
    metadata: typing.Optional["InterpretationMetadata"] = Field(default=None, description='Metadata about the interpretation: model used, per-field mapping rationale, detected sections')

class ParsedTable(BaseModel):
    table_type: typing.Optional[types.TableType] = None
    headers: typing.Optional["HeaderInfo"] = None
    aggregations: typing.Optional["AggregationInfo"] = Field(default=None, description='Present only if the table contains aggregation rows/columns')
    data_rows: typing.List[typing.List[str]] = Field(description='All data rows (excluding headers and aggregation rows). Each inner array is one row of cell values as strings.')
    notes: typing.Optional[str] = Field(default=None, description='Any caveats or observations about the table structure')

class Resume(BaseModel):
    name: typing.Optional[str] = None
    email: typing.Optional[str] = None
    experience: typing.List[str]
    skills: typing.List[str]

class TableTypeInference(BaseModel):
    table_type: typing.Optional[types.TableType] = Field(default=None, description='Table type from Step 1 (do not re-classify)')
    mapping_strategy_used: typing.Optional[str] = Field(default=None, description='Which mapping strategy was applied: \'1:1 row mapping\', \'unpivot\', \'transpose\'')

# #########################################################################
# Generated type aliases (0)
# #########################################################################
